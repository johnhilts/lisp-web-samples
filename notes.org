* Sameple Web Dev Code

* AJAX 
** GET handler that takes optional args and returns a JSON payload
** POST handler that takes multiple args and returns 201, etc

* Form
** Name text input
** Select 
** Checkbox
** Submit button
** post to AJAX handler
** Client side validation 
** Server side validation

* JS Explorations
** moment.js
-- download from here: https://momentjs.com/downloads/moment.js
** geolocation

* JS Macros
** A very poor man's jsx
I want to take something like this:
#+BEGIN_SRC lisp
(ps (defun some-js-stuff ()
 (let ((my-table  (chain document (get-element-by-id "my-table"))))
  (dolist (name names)
   (js-html (tr (td name))))))) ; this renders as <tr><td>John</td></tr> using "html" macro

(defun html-output-using-cl-who ()
(:html
(:body
(:table :id "my-table"))))
#+END_SRC

*** Brainstorming
 (tr (td name))

 (tr (td name)) <-- (listp tags) (atom (car tags)) (listp (cdr tags)) => add "<" tag recursion
 ((td name)) <-- (listp tags) (listp (car tags)) => recursion
 (td name) <-- (listp tags) (atom (car tags)) (listp (cdr tags)) => same as 1st condition
 (name) <-- (listp tags) (atom (car tags)) (null (cdr tags)) => we've found a lonely atom add atom

**** Using DOM API
***** create a table
#+BEGIN_SRC javascript
var sampleDiv = document.getElementById("sample-div")
var sampleTd = document.createElement("td")
var node = document.createTextNode("Name: John")
sampleTd.appendChild(node)
var sampleTr = document.createElement("tr")
sampleTr.appendChild(sampleTd)
var sampleTable = document.createElement("table")
sampleTable.appendChild(sampleTr)
sampleDiv.appendChild(sampleTable)
#+END_SRC

***** Scenarios
- (tr (td name))
- (tr (td name) (td age))
- (tr style (td style name) (td style age))
****** Flow
- (tr (td name))
  - get atom, create element, get next list (tr, get td)
    - get atom, create element, add any atoms as text nodes (td name)
  - append child element to this level element (tr + td)
- (tr (td name) (td age)) - should the tds be wrapped in a container list? Prolly not needed bc cdr
  - get atom, create element, get next list (tr, get td)
    - get atom, create element, add any atoms as text nodes (td name)
  - append child element to this level element (tr + td)
- (tr :style "my-style" (td :style "my-style" name) (td :style "my-style" age)) <-- make attributes keywords, and text are strings
  - go through each element in the list ...
    - (car list) - create element!
    - (keywordp & atom) - add attribute! (syntax: sampleTd.setAttribute("style", "background-color: Green;"))
    - (stringp & atom) - create text node! (to current element)
    - (listp) - recursive call! then add to current element!

* commented out code:
                                          #||
                                         ((and (keywordp (car tags)) (stringp (cadr tags)))
(format nil " ~a=\"~a\" ~a" (car tags) (cadr tags)
             (lisp->js-html-fn-deep (cddr tags)))
                                        ;    ||#

* what code might look like
** what we can do today
(ps
(let ((people (get-people-list)))
))
